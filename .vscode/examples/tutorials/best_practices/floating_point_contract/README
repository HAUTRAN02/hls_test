This tutorial demonstrates the impact of using the -ffp-contract=fast flag
and #pragma clang fp contract(fast) in i++. These options are applied to
double-precision floating-point operations. They should be used only if the
application can tolerate small differences in floating-point results.

--------------------------------------------------------------------------------
part_1_default:
--------------------------------------------------------------------------------
The first part of the tutorial shows a simple HLS component that does some
basic double-precision arithmetic operations. There are two double-precision
adds that feed into a double-precision multiplier. Once you compile this
design, review the Estimated Resource Usage section in the HLD Reports
summary page and note the area of the design and the component latency.

--------------------------------------------------------------------------------
part_2_flag: -ffp-contract=fast
--------------------------------------------------------------------------------
In part_2_flag, we compile the same source file (part_1.cpp) but with the added
compile tile flag -ffp-contract=fast. This flag tells the compiler to
optimize the intermediate rounding and normalization for floating-point
operations when possible. This optimization reduces the amount of hardware
necessary for the chaining of double-precision floating-point operations.
This flag makes two key changes:
  - Removes floating-point rounding operations and conversions when possible
  - Carries additional mantissa bits to maintain precision instead of
    applying rounding to the output of a floating-point operation.
These optimizations are useful only when you are chaining multiple double
precision floating-point operations and when these optimizations are applied
to multiple operations within that chain.

Once you compile this design, review the Estimated Resource Usage section of
HLD design report summary page to observe the area in terms of number of
ALUTs, FFs, and MLABs is significantly smaller than part_1. Also review the
Verification Statistics page (under Throughput Analysis) to observe that
part_2 finishes in much fewer cycles than part_1.

--------------------------------------------------------------------------------
part_3_pragma:
--------------------------------------------------------------------------------
In addition to command line flags, you can specify the fp-contract option
in source as a pragma. part_3_pragma.cpp shows how to use the pragma version.
You can apply the pragma at the file scope, function scope, or block scope.
You must apply the fp-contract block scope pragma at the top of the code
block (within the curly braces). However, the function scope pragma can be
applied just above the function definition. In this example
(part_3_pragma.cpp), we apply the pragma to the function scope of
test_component where we want this optimization to take place. Observe that
the hardware generated by this version is equivalent to part_2_flag that uses
the command line argument. You can confirm this by comparing the area of the
two parts in the Estimated Resource Usage section of the HLD design report
summary page. Compare the Graph Viewer for the two parts to see that the
compiler has generated identical hardware in both cases. Also review the
Verification Statistics page to see that the latency of part_3_pragma is the
same as part_2_flag.

--------------------------------------------------------------------------------
part_4_scoped:
--------------------------------------------------------------------------------
part_4 demonstrates how to use the pragma to a subset of operations within
your design. Here, only one add and the mult operations are within the scope
of the pragma. Notice that the area (in the Estimated Resource Usage section
of the HLD design report summary page) and latency (in the Verification
Statistics page) of this variant are between part_1 and part_2/part_3.

This tutorial requires the following tools to be installed:
  - Intel(R) High Level Synthesis (HLS) Compiler
  - ModelSim

To run this tutorial:
  - On Linux run "make"
  - On Windows run "build"
