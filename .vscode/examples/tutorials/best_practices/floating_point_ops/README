This tutorial demonstrates the impact of using the -ffp-reassociate flag and
fp-reassoc pragma in i++. This feature is associated with floating point
operations. It should be used only if the application can tolerate small
differences in floating-point results.

--------------------------------------------------------------------------------
part_1 (part_1_filter.cpp): baseline
--------------------------------------------------------------------------------
The first part of the tutorial serves as the baseline design and is compiled
without any special floating point flags or pragmas. This version is a good
reference point to compare part_2 and part_3.

--------------------------------------------------------------------------------
part_2 (part_1_filter.cpp): -ffp-reassociate command line flag
--------------------------------------------------------------------------------
In part_2, we compile the same source file as from part_1, but with the addition
of the -ffp-reassociate command line flag. This flag allows the relaxation in the
order of arithmetic operations. With regards to floating point operations of
equal priority, the order in which the operations are performed can impact
the final result due to rounding and precision changes.
For example, assuming a,b,c,d are floats:
  a + b + c + d != a + (b + (c + d)) != (a + b) + (c + d)
To ensure that the behavior of the hardware generated is consistent with your
native compiler, the operations must execute in the same precise order,
preventing the possibility of various optimizations that can save area. By
default, the generated hardware for (a+b+c+d) would look like:

   a     b     c     d
   |     |     |     |
    \   /      |     |
     (+)       |     |
      |        |     |
       \       |     |
        \     /      |
         \   /       |
          (+)        |
           |        /
            \      /
             \    /
              \  /
               (+)
                |
                |
              Result

This structure would accordingly have to be pipelined with register chains to
achieve high throughput. This example design is a 32-tap filter. As such, the
amount of pipeline registers required to conform to this structure can get
fairly large and does not scale well. You can refer to the cluster view in the
Graph Viewer in the reports of part_1_default to see this structure of chained
floating-point dot products of size 2 in the datapath.

If you not care about the exact ordering in which these operations are executed,
you can include the -ffp-reassociate flag as a compile time argument to i++.
Specifying this flag allows the compiler to generate the best structure for the
provided set of operations. The above example, instead of being a vine-like
structure, would generate a tree-like structure when -ffp-reassociate is enabled.

   a     b     c     d
   |     |     |     |
    \   /       \   /
     (+)         (+)
      |           |
       \         /
        \       /
         \     /
          \   /
           (+)
            |
            |
          Result

This tree-like structure is shallower so it requires fewer pipelining
registers. It also scales much better to longer chains as it is log(N) scaling
as compared to N in the default case. The cluster view of the Graph Viewer
shows that the compiler collapses the floating-point dot products of size 2
into a floating-point dot product of size 32. You can compare this to part_1
where all of the operations are separate.
You can also compare the latency of part_1 and that of part_2 in Verification
Statistics after running simulation. Part_2 has a much smaller latency than
part_1 due to the shallower datapath structure. 

--------------------------------------------------------------------------------
part_3 (part_3_filter_pragma.cpp): Using a pragma
--------------------------------------------------------------------------------
In addition to command line flags, the fp-reassoc pragma can be specified
within a block scope in source. part_3 shows how to use the pragma version of
this option. The pragma can be applied at the file scope, function scope, or
block scope. For block scope, the pragma must be at the top of the code block
(within the curly braces). In this example (part_3_pragma), we apply the pragma
to the block scope at the main compute block where we want to relax the
floating point operations. You can observe that the hardware generated by this
version is equivalent to part_2_optimized which uses the command line argument
instead.

For more information on this flag and pragma, please refer to the i++
documentation.

This tutorial requires the following tools to be installed:
  - Intel(R) High Level Synthesis (HLS) Compiler
  - ModelSim

To run this tutorial:
  - On Linux run "make"
  - On Windows run "build"

