This tutorial demonstrates how you can apply memory attributes to struct
member variables to control the memory systems generated by the compiler.
In terms of applying memory attributes to data members, classes and 
structs are equivalent. 

For more information about memory attributes, see Table "Intel HLS Compiler
Component Memory Attributes" in the Intel HLS Compiler Reference Manual.

This tutorial is divided into the following parts:

  - Part 1 guides you on the basic usage of attributes on member variables of
    a struct.

  - Part 2 explains how an array of struct objects interact with attributes
    on member variables.

  - Part 3 describes the interaction between attributes applied to a struct
    object instantiation and attributes applied to member variables in 
    struct declaration.

In this tutorial, we define a struct "State" with two member variables:
"register_attr" and "memory_attr". We apply the hls_register attribute to
"register_attr", which asks the compiler to implement this variable in
registers. For the second member variable named "memory_attr", we apply the
hls_memory attribute to request the compiler to implement it in MLABs or block
RAMs.

Run the tutorial as described at the end of this document.

1. Memory attributes on struct member variables
===============================================

  In the first part (part_1_attr_ok.cpp), an object of struct State named
  "MyState" is instantiated inside a component.

  Open the high-level design report (part_1_attr_ok.prj/reports/report.html),
  and go to the Function Memory Viewer (System Viewers > Function Memory
  Viewer). In the Function Memory List pane, expand "attr_ok" and 
  click "MyState.register_attr" and "MyState.memory_attr". You can see that 
  "MyState.memory_attr" is implemented in memory, while "MyState.register_attr" 
  is implemented in registers.

2. Array of structs
===================

  In the second version (part_2_array_prevails.cpp), an array of struct
  "State" is declared and it is accessed dynamically (i.e. the index being
  accessed is not known at compile time). Because its an array with a dynamic
  access, it becomes a single memory system. In other words, the attributes
  applied to the struct member variables are ignored by the compiler. A
  warning is issued about this.

  Open the high-level design report
  (part_2_array_prevails.prj/reports/report.html), and go to the Function
  Memory Viewer (System Viewers > Function Memory Viewer). In the Function
  Memory List pane, expand function "array_prevails". You can see that there
  is a single memory called "MyStateArray".

3. Memory attributes on the struct instantiation
================================================

  In the third version (part_3_outer_prevails.cpp), an object of struct State
  named "MyState"is instantiated and attribute hls_memory is applied to it.
  Because there is an attribute on the struct instantiation, the attributes
  applied to the struct member variables (in the struct declaration) are
  ignored by the compiler. A warning is issued about this.

  Open the high-level design report
  (part_3_outer_prevails.prj/reports/report.html), and go to the Function
  Memory Viewer (System Viewers > Function Memory Viewer). In the Function
  Memory List pane, expand the function "outer_prevails". You can see that
  there is a single memory called "MyState".

Summary
=======

You can apply memory attributes to data members of a class or struct in the
class or struct declaration. The compiler will respect the attributes for all
object instantiations of class or struct, unless:
  - an object instantiation itself has attributes, in which case the
    attributes on the struct object instantiation take precedence.
  - a dynamically accessed array of structs is declared.

Whenever the compiler ignores attributes applied to data members of a
class or struct, it issues a warning.

This tutorial requires the following tools to be installed:
  - Intel(R) High Level Synthesis (HLS) Compiler
  - ModelSim

To run this tutorial:
  - On Linux run "make"
  - On Windows run "build"

